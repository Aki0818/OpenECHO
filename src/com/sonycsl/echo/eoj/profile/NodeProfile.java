/*
 * Copyright 2012 Sony Computer Science Laboratories, Inc. <info@kadecot.net>
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.sonycsl.echo.eoj.profile;

import com.sonycsl.echo.EchoFrame;
import com.sonycsl.echo.EchoUtils;
import com.sonycsl.echo.eoj.EchoObject;
import com.sonycsl.echo.eoj.profile.ProfileObject.Getter;
import com.sonycsl.echo.eoj.profile.ProfileObject.Setter;

public abstract class NodeProfile extends ProfileObject {
	@SuppressWarnings("unused")
	private static final String TAG = NodeProfile.class.getSimpleName();
	
	public static final byte CLASS_GROUP_CODE = (byte)0x0E;
	public static final byte CLASS_CODE = (byte)0xF0;
	public static final byte INSTANCE_CODE = (byte)0x01;
	
	protected static final byte EPC_OPERATING_STATUS = (byte)0x80;
	protected static final byte EPC_VERSION_INFORMATION = (byte)0x82;
	protected static final byte EPC_IDENTIFICATION_NUMBER = (byte)0x83;
	protected static final byte EPC_FAULT_CONTENT = (byte)0x89;
	protected static final byte EPC_UNIQUE_IDENTIFIER_DATA = (byte)0xBF;
	protected static final byte EPC_NUMBER_OF_SELF_NODE_INSTANCES = (byte)0xD3;
	protected static final byte EPC_NUMBER_OF_SELF_NODE_CLASSES = (byte)0xD4;
	protected static final byte EPC_INSTANCE_LIST_NOTIFICATION = (byte)0xD5;
	protected static final byte EPC_SELF_NODE_INSTANCE_LIST_S = (byte)0xD6;
	protected static final byte EPC_SELF_NODE_CLASS_LIST = (byte)0xD7; 

	@Override
	public byte getClassGroupCode() {
		return CLASS_GROUP_CODE;
	}

	@Override
	public byte getClassCode() {
		return CLASS_CODE;
	}

	@Override
	public byte getInstanceCode() {
		return INSTANCE_CODE;
	}

	/**
	 * Indicates node operating status.<br>
	 * <br>
	 * Booting = 0x30, not booting = 0x31<br>
	 * <br>
	 * Name : Operating status<br>
	 * EPC : 0x80<br>
	 * Data Type : unsigned char<br>
	 * Data Size(Byte) : 1<br>
	 * <br>
	 * AccessRule<br>
	 * Announce : undefined<br>
	 * Set : optional<br>
	 * Get : mandatory<br>
	 * <br>
	 * Announcement at status change<br>
	 */
	protected boolean setOperatingStatus(byte[] edt) {
		return false;
	}
	private final boolean _setOperatingStatus(byte epc, byte[] edt) {
		boolean success = setOperatingStatus(edt);
		onInvokedSetMethod(epc, edt, success);
		return success;
	}
	/**
	 * Indicates node operating status.<br>
	 * <br>
	 * Booting = 0x30, not booting = 0x31<br>
	 * <br>
	 * Name : Operating status<br>
	 * EPC : 0x80<br>
	 * Data Type : unsigned char<br>
	 * Data Size(Byte) : 1<br>
	 * <br>
	 * AccessRule<br>
	 * Announce : undefined<br>
	 * Set : optional<br>
	 * Get : mandatory<br>
	 * <br>
	 * Announcement at status change<br>
	 */
	protected abstract byte[] getOperatingStatus();
	private final byte[] _getOperatingStatus(byte epc) {
		byte[] edt = getOperatingStatus();
		onInvokedGetMethod(epc, edt);
		return edt;
	}
	
	/**
	 * Indicates ECHONET Lite version<br>
	 * used by communication middleware and message types supported by communication middleware.<br>
	 * <br>
	 * 1st byte: Indicates major version number (digits to left of decimal point) in binary notation.<br>
	 * 2nd byte: Indicates minor version number (digits to right of decimal point) in binary notation.<br>
	 * 3rd and 4th bytes: Indicate message types with a bitmap.<br>
	 * <br>
	 * Name : Version information<br>
	 * EPC : 0x82<br>
	 * Data Type : unsigned char×4<br>
	 * Data Size(Byte) : 4<br>
	 * <br>
	 * AccessRule<br>
	 * Announce : undefined<br>
	 * Set : undefined<br>
	 * Get : mandatory<br>
	 */
	protected abstract byte[] getVersionInformation();
	private final byte[] _getVersionInformation(byte epc) {
		byte[] edt = getVersionInformation();
		onInvokedGetMethod(epc, edt);
		return edt;
	}
	
	/**
	 * Number to identify the node implementing the device object in the domain.<br>
	 * <br>
	 * 1st byte: lower communication ID field<br>
	 * 0x01 to 0xFD：<br>
	 * Set arbitrarily for the protocol when the communication protocol used in the lower communication layer has a unique number. (not used in the ECHONET Lite Specification)<br>
	 * 0xFE:<br>
	 * Set 2 to 17 bytes in the manufacturer-specified format.<br>
	 * 0xFF:<br>
	 * Set 2 to 9 bytes when the protocol generated by random numbers is used in the lower communication layer.<br>
	 * 0x00:<br>
	 * Identification number is not set.<br>
	 * Over 2nd byte: unique number field<br>
	 * <br>
	 * Name : Identification number<br>
	 * EPC : 0x83<br>
	 * Data Type : unsigned char×9 or unsigned char × 17<br>
	 * Data Size(Byte) : 9 or 17<br>
	 * <br>
	 * AccessRule<br>
	 * Announce : undefined<br>
	 * Set : undefined<br>
	 * Get : mandatory<br>
	 */
	protected abstract byte[] getIdentificationNumber();
	private final byte[] _getIdentificationNumber(byte epc) {
		byte[] edt = getIdentificationNumber();
		onInvokedGetMethod(epc, edt);
		return edt;
	}
	
	/**
	 * Fault content<br>
	 * <br>
	 * 0x0000-0x03E8 (0-1000)<br>
	 * <br>
	 * Name : Fault content<br>
	 * EPC : 0x89<br>
	 * Data Type : unsigned short<br>
	 * Data Size(Byte) : 2<br>
	 * <br>
	 * AccessRule<br>
	 * Announce : undefined<br>
	 * Set : undefined<br>
	 * Get : optional<br>
	 */
	protected byte[] getFaultContent() {
		return null;
	}
	private final byte[] _getFaultContent(byte epc) {
		byte[] edt = getFaultContent();
		onInvokedGetMethod(epc, edt);
		return edt;
	}
	
	/**
	 * Stipulated in 2 bytes<br>
	 * <br>
	 * See (3) below.<br>
	 * <br>
	 * Name : Unique identifier data<br>
	 * EPC : 0xBF<br>
	 * Data Type : unsigned short<br>
	 * Data Size(Byte) : 2<br>
	 * <br>
	 * AccessRule<br>
	 * Announce : undefined<br>
	 * Set : mandatory<br>
	 * Get : mandatory<br>
	 */
	protected abstract boolean setUniqueIdentifierData(byte[] edt);
	private final boolean _setUniqueIdentifierData(byte epc, byte[] edt) {
		boolean success = setUniqueIdentifierData(edt);
		onInvokedSetMethod(epc, edt, success);
		return success;
	}
	
	/**
	 * Stipulated in 2 bytes<br>
	 * <br>
	 * See (3) below.<br>
	 * <br>
	 * Name : Unique identifier data<br>
	 * EPC : 0xBF<br>
	 * Data Type : unsigned short<br>
	 * Data Size(Byte) : 2<br>
	 * <br>
	 * AccessRule<br>
	 * Announce : undefined<br>
	 * Set : mandatory<br>
	 * Get : mandatory<br>
	 */
	protected abstract byte[] getUniqueIdentifierData();
	private final byte[] _getUniqueIdentifierData(byte epc) {
		byte[] edt = getUniqueIdentifierData();
		onInvokedGetMethod(epc, edt);
		return edt;
	}
	
	/**
	 * Total number of instances held by self-node<br>
	 * <br>
	 * 1st to 3rd bytes: Total number of instances<br>
	 * <br>
	 * Name : Number of self-node instances<br>
	 * EPC : 0xD3<br>
	 * Data Type : unsigned char×3<br>
	 * Data Size(Byte) : 3<br>
	 * <br>
	 * AccessRule<br>
	 * Announce : undefined<br>
	 * Set : undefined<br>
	 * Get : mandatory<br>
	 */
	protected byte[] getNumberOfSelfNodeInstances() {
		byte[] ret = new byte[3];
		int num = getNode().getDevices().length;
		
		ret[2] = (byte)(num & 0xFF);
		ret[1] = (byte)((num >> 8) & 0xFF);
		ret[0] = (byte)((num >> 16) & 0xFF);
		return ret;
	}
	private final byte[] _getNumberOfSelfNodeInstances(byte epc) {
		byte[] edt = getNumberOfSelfNodeInstances();
		onInvokedGetMethod(epc, edt);
		return edt;
	}
	
	/**
	 * Total number of classes held by self-node<br>
	 * <br>
	 * 1st and 2nd bytes: Total number of classes<br>
	 * <br>
	 * Name : Number of self-node classes<br>
	 * EPC : 0xD4<br>
	 * Data Type : unsigned char×2<br>
	 * Data Size(Byte) : 2<br>
	 * <br>
	 * AccessRule<br>
	 * Announce : undefined<br>
	 * Set : undefined<br>
	 * Get : mandatory<br>
	 */
	protected byte[] getNumberOfSelfNodeClasses() {
		return getNode().getNumberOfSelfNodeClasses();
	}
	private final byte[] _getNumberOfSelfNodeClasses(byte epc) {
		byte[] edt = getNumberOfSelfNodeClasses();
		onInvokedGetMethod(epc, edt);
		return edt;
	}
	
	/**
	 * Instance list when self-node instance configuration is changed<br>
	 * <br>
	 * 1st byte: Number of notification instances<br>
	 * 2nd to 253rd bytes: ECHONET object codes (EOJ3 bytes) enumerated<br>
	 * <br>
	 * Name : Instance list notification<br>
	 * EPC : 0xD5<br>
	 * Data Type : unsigned char×(MAX) 253<br>
	 * Data Size(Byte) : Max.253<br>
	 * <br>
	 * AccessRule<br>
	 * Announce : mandatory<br>
	 * Set : undefined<br>
	 * Get : undefined<br>
	 * <br>
	 * Announcement at status change<br>
	 */
	protected byte[] getInstanceListNotification() {
		return EchoUtils.devicesToByteArray(getNode().getDevices());
	}
	private final byte[] _getInstanceListNotification(byte epc) {
		byte[] edt = getInstanceListNotification();
		onInvokedGetMethod(epc, edt);
		return edt;
	}
	
	/**
	 * Self-node instance list<br>
	 * <br>
	 * 1st byte: Total number of instances<br>
	 * 2nd to 253rd bytes: ECHONET object codes (EOJ3 bytes) enumerated<br>
	 * <br>
	 * Name : Self-node instance list S<br>
	 * EPC : 0xD6<br>
	 * Data Type : unsigned char×(MAX) 253<br>
	 * Data Size(Byte) : Max.253<br>
	 * <br>
	 * AccessRule<br>
	 * Announce : undefined<br>
	 * Set : undefined<br>
	 * Get : mandatory<br>
	 */
	protected byte[] getSelfNodeInstanceListS() {
		return getInstanceListNotification();
	}
	private final byte[] _getSelfNodeInstanceListS(byte epc) {
		byte[] edt = getSelfNodeInstanceListS();
		onInvokedGetMethod(epc, edt);
		return edt;
	}
	

	/**
	 * Self-node class list<br>
	 * <br>
	 * 1st byte: Total number of classes<br>
	 * 2nd to 17th bytes: Class codes (EOJ high-order 2 bytes) enumerated<br>
	 * <br>
	 * Name : Self-node class list<br>
	 * EPC : 0xD7<br>
	 * Data Type : unsigned char×(MAX) 17<br>
	 * Data Size(Byte) : Max.17<br>
	 * <br>
	 * AccessRule<br>
	 * Announce : undefined<br>
	 * Set : undefined<br>
	 * Get : mandatory<br>
	 */
	protected byte[] getSelfNodeClassList() {
		return getNode().getSelfNodeClassList();
	}
	private final byte[] _getSelfNodeClassList(byte epc) {
		byte[] edt = getSelfNodeClassList();
		onInvokedGetMethod(epc, edt);
		return edt;
	}

	@Override
	protected final void onReceiveSet(EchoFrame res, byte epc, byte pdc, byte[] edt) {
		super.onReceiveSet(res, epc, pdc, edt);
		switch(epc) {
		case EPC_OPERATING_STATUS:
			res.addProperty(epc, edt, _setOperatingStatus(epc, edt));
			break;
		case EPC_UNIQUE_IDENTIFIER_DATA:
			res.addProperty(epc, edt, _setUniqueIdentifierData(epc, edt));
			break;
		}
	}

	@Override
	protected final void onReceiveGet(EchoFrame res, byte epc) {
		super.onReceiveGet(res, epc);
		byte[] edt;
		switch(epc) {
		case EPC_OPERATING_STATUS:
			edt = _getOperatingStatus(epc);
			res.addProperty(epc, edt, (edt != null && edt.length == 1));
			break;
		case EPC_VERSION_INFORMATION:
			edt = _getVersionInformation(epc);
			res.addProperty(epc, edt, (edt != null && edt.length == 4));
			break;
		case EPC_IDENTIFICATION_NUMBER:
			edt = _getIdentificationNumber(epc);
			res.addProperty(epc, edt, (edt != null && (edt.length == 9 || edt.length == 17)));
			break;
		case EPC_FAULT_CONTENT:
			edt = _getFaultContent(epc);
			res.addProperty(epc, edt, (edt != null && edt.length == 2));
			break;
		case EPC_UNIQUE_IDENTIFIER_DATA:
			edt = _getUniqueIdentifierData(epc);
			res.addProperty(epc, edt, (edt != null && edt.length == 2));
			break;
		case EPC_NUMBER_OF_SELF_NODE_INSTANCES:
			edt = _getNumberOfSelfNodeInstances(epc);
			res.addProperty(epc, edt, (edt != null && edt.length == 3));
			break;
		case EPC_NUMBER_OF_SELF_NODE_CLASSES:
			edt = _getNumberOfSelfNodeClasses(epc);
			res.addProperty(epc, edt, (edt != null && edt.length == 2));
			break;
		case EPC_SELF_NODE_INSTANCE_LIST_S:
			edt = _getSelfNodeInstanceListS(epc);
			res.addProperty(epc, edt, (edt != null && edt.length <= 253));
			break;
		case EPC_SELF_NODE_CLASS_LIST:
			edt = _getSelfNodeClassList(epc);
			res.addProperty(epc, edt, (edt != null && edt.length <= 253));
			break;
		}
	}

	@Override
	protected final void onReceiveInfReq(EchoFrame res, byte epc) {
		super.onReceiveInfReq(res, epc);
		byte[] edt;
		switch(epc) {
		case EPC_INSTANCE_LIST_NOTIFICATION:
			edt = _getInstanceListNotification(epc);
			res.addProperty(epc, edt, (edt != null && edt.length <= 253));
			break;
		}
	}

	@Override
	public Setter set() {
		return new Setter(ESV_SETI);
	}

	@Override
	public Setter setC() {
		return new Setter(ESV_SETC);
	}

	@Override
	public Getter get() {
		return new Getter();
	}

	@Override
	public Informer inform() {
		return new InformerImpl();
	}

	@Override
	protected InformerC informC() {
		return new InformerC();
	}


	public static class Receiver extends ProfileObject.Receiver {
		
		@Override
		protected final void onReceiveSetRes(EchoObject eoj, short tid, byte esv, byte epc, byte pdc, byte[] edt) {
			super.onReceiveSetRes(eoj, tid, esv, epc, pdc, edt);
			switch(epc) {
			case EPC_OPERATING_STATUS:
				_onSetOperatingStatus(eoj, tid, esv, epc, pdc, edt, (pdc != 0));
				break;
			case EPC_UNIQUE_IDENTIFIER_DATA:
				_onSetUniqueIdentifierData(eoj, tid, esv, epc, pdc, edt, (pdc != 0));
				break;
			}
		}

		@Override
		protected final void onReceiveGetRes(EchoObject eoj, short tid, byte esv, byte epc, byte pdc, byte[] edt) {
			super.onReceiveGetRes(eoj, tid, esv, epc, pdc, edt);
			switch(epc) {
			case EPC_OPERATING_STATUS:
				_onGetOperatingStatus(eoj, tid, esv, epc, pdc, edt);
				break;
			case EPC_VERSION_INFORMATION:
				_onGetVersionInformation(eoj, tid, esv, epc, pdc, edt);
				break;
			case EPC_IDENTIFICATION_NUMBER:
				_onGetIdentificationNumber(eoj, tid, esv, epc, pdc, edt);
				break;
			case EPC_FAULT_CONTENT:
				_onGetFaultContent(eoj, tid, esv, epc, pdc, edt);
				break;
			case EPC_UNIQUE_IDENTIFIER_DATA:
				_onGetUniqueIdentifierData(eoj, tid, esv, epc, pdc, edt);
				break;
			case EPC_NUMBER_OF_SELF_NODE_INSTANCES:
				_onGetNumberOfSelfNodeInstances(eoj, tid, esv, epc, pdc, edt);
				break;
			case EPC_NUMBER_OF_SELF_NODE_CLASSES:
				_onGetNumberOfSelfNodeClasses(eoj, tid, esv, epc, pdc, edt);
				break;
			case EPC_INSTANCE_LIST_NOTIFICATION:
				_onGetInstanceListNotification(eoj, tid, esv, epc, pdc, edt);
				break;
			case EPC_SELF_NODE_INSTANCE_LIST_S:
				_onGetSelfNodeInstanceListS(eoj, tid, esv, epc, pdc, edt);
				break;
			case EPC_SELF_NODE_CLASS_LIST:
				_onGetSelfNodeClassList(eoj, tid, esv, epc, pdc, edt);
				break;
			}
		}

		@Override
		protected final void onReceiveInfC(EchoObject eoj, short tid, byte esv, byte epc, byte pdc, byte[] edt) {
			super.onReceiveInfC(eoj, tid, esv, epc, pdc, edt);
			switch(epc) {
			case EPC_INSTANCE_LIST_NOTIFICATION:
				_onGetInstanceListNotification(eoj, tid, esv, epc, pdc, edt);
				break;
			}
		}

		@Override
		protected final void onReceiveInfCRes(EchoObject eoj, short tid, byte esv, byte epc, byte pdc, byte[] edt) {
			super.onReceiveInfCRes(eoj, tid, esv, epc, pdc, edt);
			switch(epc) {
			case EPC_INSTANCE_LIST_NOTIFICATION:
				_onInformInstanceListNotification(eoj, tid, esv, epc);
				break;
			}
		}
		
		/**
		 * Indicates node operating status.<br>
		 * <br>
		 * Booting = 0x30, not booting = 0x31<br>
		 * <br>
		 * Name : Operating status<br>
		 * EPC : 0x80<br>
		 * Data Type : unsigned char<br>
		 * Data Size(Byte) : 1<br>
		 * <br>
		 * AccessRule<br>
		 * Announce : undefined<br>
		 * Set : optional<br>
		 * Get : mandatory<br>
		 * <br>
		 * Announcement at status change<br>
		 */
		protected void onSetOperatingStatus(EchoObject eoj, short tid, byte esv, byte epc, byte pdc, byte[] edt, boolean success) {}
		private final void _onSetOperatingStatus(EchoObject eoj, short tid, byte esv, byte epc, byte pdc, byte[] edt, boolean success) {
			onSetOperatingStatus(eoj, tid, esv, epc, pdc, edt, success);
			onInvokedOnSetMethod(eoj, tid, esv, epc, pdc, edt, success);
		}
		
		/**
		 * Indicates node operating status.<br>
		 * <br>
		 * Booting = 0x30, not booting = 0x31<br>
		 * <br>
		 * Name : Operating status<br>
		 * EPC : 0x80<br>
		 * Data Type : unsigned char<br>
		 * Data Size(Byte) : 1<br>
		 * <br>
		 * AccessRule<br>
		 * Announce : undefined<br>
		 * Set : optional<br>
		 * Get : mandatory<br>
		 * <br>
		 * Announcement at status change<br>
		 */
		protected void onGetOperatingStatus(EchoObject eoj, short tid, byte esv, byte epc, byte pdc, byte[] edt) {}
		private final void _onGetOperatingStatus(EchoObject eoj, short tid, byte esv, byte epc, byte pdc, byte[] edt) {
			onGetOperatingStatus(eoj, tid, esv, epc, pdc, edt);
			onInvokedOnGetMethod(eoj, tid, esv, epc, pdc, edt);
		}

		/**
		 * Indicates ECHONET Lite version<br>
		 * used by communication middleware and message types supported by communication middleware.<br>
		 * <br>
		 * 1st byte: Indicates major version number (digits to left of decimal point) in binary notation.<br>
		 * 2nd byte: Indicates minor version number (digits to right of decimal point) in binary notation.<br>
		 * 3rd and 4th bytes: Indicate message types with a bitmap.<br>
		 * <br>
		 * Name : Version information<br>
		 * EPC : 0x82<br>
		 * Data Type : unsigned char×4<br>
		 * Data Size(Byte) : 4<br>
		 * <br>
		 * AccessRule<br>
		 * Announce : undefined<br>
		 * Set : undefined<br>
		 * Get : mandatory<br>
		 */
		protected void onGetVersionInformation(EchoObject eoj, short tid, byte esv, byte epc, byte pdc, byte[] edt) {}
		private final void _onGetVersionInformation(EchoObject eoj, short tid, byte esv, byte epc, byte pdc, byte[] edt) {
			onGetVersionInformation(eoj, tid, esv, epc, pdc, edt);
			onInvokedOnGetMethod(eoj, tid, esv, epc, pdc, edt);
		}

		/**
		 * Number to identify the node implementing the device object in the domain.<br>
		 * <br>
		 * 1st byte: lower communication ID field<br>
		 * 0x01 to 0xFD：<br>
		 * Set arbitrarily for the protocol when the communication protocol used in the lower communication layer has a unique number. (not used in the ECHONET Lite Specification)<br>
		 * 0xFE:<br>
		 * Set 2 to 17 bytes in the manufacturer-specified format.<br>
		 * 0xFF:<br>
		 * Set 2 to 9 bytes when the protocol generated by random numbers is used in the lower communication layer.<br>
		 * 0x00:<br>
		 * Identification number is not set.<br>
		 * Over 2nd byte: unique number field<br>
		 * <br>
		 * Name : Identification number<br>
		 * EPC : 0x83<br>
		 * Data Type : unsigned char×9 or unsigned char × 17<br>
		 * Data Size(Byte) : 9 or 17<br>
		 * <br>
		 * AccessRule<br>
		 * Announce : undefined<br>
		 * Set : undefined<br>
		 * Get : mandatory<br>
		 */
		protected void onGetIdentificationNumber(EchoObject eoj, short tid, byte esv, byte epc, byte pdc, byte[] edt) {}
		private final void _onGetIdentificationNumber(EchoObject eoj, short tid, byte esv, byte epc, byte pdc, byte[] edt) {
			onGetIdentificationNumber(eoj, tid, esv, epc, pdc, edt);
			onInvokedOnGetMethod(eoj, tid, esv, epc, pdc, edt);
		}

		/**
		 * Fault content<br>
		 * <br>
		 * 0x0000-0x03E8 (0-1000)<br>
		 * <br>
		 * Name : Fault content<br>
		 * EPC : 0x89<br>
		 * Data Type : unsigned short<br>
		 * Data Size(Byte) : 2<br>
		 * <br>
		 * AccessRule<br>
		 * Announce : undefined<br>
		 * Set : undefined<br>
		 * Get : optional<br>
		 */
		protected void onGetFaultContent(EchoObject eoj, short tid, byte esv, byte epc, byte pdc, byte[] edt) {}
		private final void _onGetFaultContent(EchoObject eoj, short tid, byte esv, byte epc, byte pdc, byte[] edt) {
			onGetFaultContent(eoj, tid, esv, epc, pdc, edt);
			onInvokedOnGetMethod(eoj, tid, esv, epc, pdc, edt);
		}
		
		/**
		 * Stipulated in 2 bytes<br>
		 * <br>
		 * See (3) below.<br>
		 * <br>
		 * Name : Unique identifier data<br>
		 * EPC : 0xBF<br>
		 * Data Type : unsigned short<br>
		 * Data Size(Byte) : 2<br>
		 * <br>
		 * AccessRule<br>
		 * Announce : undefined<br>
		 * Set : mandatory<br>
		 * Get : mandatory<br>
		 */
		protected void onSetUniqueIdentifierData(EchoObject eoj, short tid, byte esv, byte epc, byte pdc, byte[] edt, boolean success) {}
		private final void _onSetUniqueIdentifierData(EchoObject eoj, short tid, byte esv, byte epc, byte pdc, byte[] edt, boolean success) {
			onSetUniqueIdentifierData(eoj, tid, esv, epc, pdc, edt, success);
			onInvokedOnSetMethod(eoj, tid, esv, epc, pdc, edt, success);
		}

		/**
		 * Stipulated in 2 bytes<br>
		 * <br>
		 * See (3) below.<br>
		 * <br>
		 * Name : Unique identifier data<br>
		 * EPC : 0xBF<br>
		 * Data Type : unsigned short<br>
		 * Data Size(Byte) : 2<br>
		 * <br>
		 * AccessRule<br>
		 * Announce : undefined<br>
		 * Set : mandatory<br>
		 * Get : mandatory<br>
		 */
		protected void onGetUniqueIdentifierData(EchoObject eoj, short tid, byte esv, byte epc, byte pdc, byte[] edt) {}
		private final void _onGetUniqueIdentifierData(EchoObject eoj, short tid, byte esv, byte epc, byte pdc, byte[] edt) {
			onGetUniqueIdentifierData(eoj, tid, esv, epc, pdc, edt);
			onInvokedOnGetMethod(eoj, tid, esv, epc, pdc, edt);
		}

		/**
		 * Total number of instances held by self-node<br>
		 * <br>
		 * 1st to 3rd bytes: Total number of instances<br>
		 * <br>
		 * Name : Number of self-node instances<br>
		 * EPC : 0xD3<br>
		 * Data Type : unsigned char×3<br>
		 * Data Size(Byte) : 3<br>
		 * <br>
		 * AccessRule<br>
		 * Announce : undefined<br>
		 * Set : undefined<br>
		 * Get : mandatory<br>
		 */
		protected void onGetNumberOfSelfNodeInstances(EchoObject eoj, short tid, byte esv, byte epc, byte pdc, byte[] edt) {}
		private final void _onGetNumberOfSelfNodeInstances(EchoObject eoj, short tid, byte esv, byte epc, byte pdc, byte[] edt) {
			onGetNumberOfSelfNodeInstances(eoj, tid, esv, epc, pdc, edt);
			onInvokedOnGetMethod(eoj, tid, esv, epc, pdc, edt);
		}
		
		/**
		 * Total number of classes held by self-node<br>
		 * <br>
		 * 1st and 2nd bytes: Total number of classes<br>
		 * <br>
		 * Name : Number of self-node classes<br>
		 * EPC : 0xD4<br>
		 * Data Type : unsigned char×2<br>
		 * Data Size(Byte) : 2<br>
		 * <br>
		 * AccessRule<br>
		 * Announce : undefined<br>
		 * Set : undefined<br>
		 * Get : mandatory<br>
		 */
		protected void onGetNumberOfSelfNodeClasses(EchoObject eoj, short tid, byte esv, byte epc, byte pdc, byte[] edt) {}
		private final void _onGetNumberOfSelfNodeClasses(EchoObject eoj, short tid, byte esv, byte epc, byte pdc, byte[] edt) {
			onGetNumberOfSelfNodeClasses(eoj, tid, esv, epc, pdc, edt);
			onInvokedOnGetMethod(eoj, tid, esv, epc, pdc, edt);
		}

		/**
		 * Instance list when self-node instance configuration is changed<br>
		 * <br>
		 * 1st byte: Number of notification instances<br>
		 * 2nd to 253rd bytes: ECHONET object codes (EOJ3 bytes) enumerated<br>
		 * <br>
		 * Name : Instance list notification<br>
		 * EPC : 0xD5<br>
		 * Data Type : unsigned char×(MAX) 253<br>
		 * Data Size(Byte) : Max.253<br>
		 * <br>
		 * AccessRule<br>
		 * Announce : mandatory<br>
		 * Set : undefined<br>
		 * Get : undefined<br>
		 * <br>
		 * Announcement at status change<br>
		 */
		protected void onGetInstanceListNotification(EchoObject eoj, short tid, byte esv, byte epc, byte pdc, byte[] edt) {}
		private final void _onGetInstanceListNotification(EchoObject eoj, short tid, byte esv, byte epc, byte pdc, byte[] edt) {
			onGetInstanceListNotification(eoj, tid, esv, epc, pdc, edt);
			onInvokedOnGetMethod(eoj, tid, esv, epc, pdc, edt);
		}
		
		/**
		 * Instance list when self-node instance configuration is changed<br>
		 * <br>
		 * 1st byte: Number of notification instances<br>
		 * 2nd to 253rd bytes: ECHONET object codes (EOJ3 bytes) enumerated<br>
		 * <br>
		 * Name : Instance list notification<br>
		 * EPC : 0xD5<br>
		 * Data Type : unsigned char×(MAX) 253<br>
		 * Data Size(Byte) : Max.253<br>
		 * <br>
		 * AccessRule<br>
		 * Announce : mandatory<br>
		 * Set : undefined<br>
		 * Get : undefined<br>
		 * <br>
		 * Announcement at status change<br>
		 */
		protected void onInformInstanceListNotification(EchoObject eoj, short tid, byte esv, byte epc) {}
		private final void _onInformInstanceListNotification(EchoObject eoj, short tid, byte esv, byte epc) {
			onInformInstanceListNotification(eoj, tid, esv, epc);
			onInvokedOnInformMethod(eoj, tid, esv, epc);
		}
		
		/**
		 * Self-node instance list<br>
		 * <br>
		 * 1st byte: Total number of instances<br>
		 * 2nd to 253rd bytes: ECHONET object codes (EOJ3 bytes) enumerated<br>
		 * <br>
		 * Name : Self-node instance list S<br>
		 * EPC : 0xD6<br>
		 * Data Type : unsigned char×(MAX) 253<br>
		 * Data Size(Byte) : Max.253<br>
		 * <br>
		 * AccessRule<br>
		 * Announce : undefined<br>
		 * Set : undefined<br>
		 * Get : mandatory<br>
		 */
		protected void onGetSelfNodeInstanceListS(EchoObject eoj, short tid, byte esv, byte epc, byte pdc, byte[] edt) {}
		private final void _onGetSelfNodeInstanceListS(EchoObject eoj, short tid, byte esv, byte epc, byte pdc, byte[] edt) {
			onGetSelfNodeInstanceListS(eoj, tid, esv, epc, pdc, edt);
			onInvokedOnGetMethod(eoj, tid, esv, epc, pdc, edt);
		}
		
		/**
		 * Self-node class list<br>
		 * <br>
		 * 1st byte: Total number of classes<br>
		 * 2nd to 17th bytes: Class codes (EOJ high-order 2 bytes) enumerated<br>
		 * <br>
		 * Name : Self-node class list<br>
		 * EPC : 0xD7<br>
		 * Data Type : unsigned char×(MAX) 17<br>
		 * Data Size(Byte) : Max.17<br>
		 * <br>
		 * AccessRule<br>
		 * Announce : undefined<br>
		 * Set : undefined<br>
		 * Get : mandatory<br>
		 */
		protected void onGetSelfNodeClassList(EchoObject eoj, short tid, byte esv, byte epc, byte pdc, byte[] edt) {}
		private final void _onGetSelfNodeClassList(EchoObject eoj, short tid, byte esv, byte epc, byte pdc, byte[] edt) {
			onGetSelfNodeClassList(eoj, tid, esv, epc, pdc, edt);
			onInvokedOnGetMethod(eoj, tid, esv, epc, pdc, edt);
		}
		
	}
	
	public class Setter extends ProfileObject.Setter {
		
		public Setter(byte esv) {
			super(esv);
		}
		
		@Override
		public Setter reqSet(byte epc, byte[] edt) {
			return (Setter)super.reqSet(epc, edt);
		}
		/**
		 * Indicates node operating status.<br>
		 * <br>
		 * Booting = 0x30, not booting = 0x31<br>
		 * <br>
		 * Name : Operating status<br>
		 * EPC : 0x80<br>
		 * Data Type : unsigned char<br>
		 * Data Size(Byte) : 1<br>
		 * <br>
		 * AccessRule<br>
		 * Announce : undefined<br>
		 * Set : optional<br>
		 * Get : mandatory<br>
		 * <br>
		 * Announcement at status change<br>
		 */
		public Setter reqSetOperatingStatus(byte[] edt) {
			addProperty(EPC_OPERATING_STATUS, edt, (edt.length == 1));
			return this;
		}
		/**
		 * Stipulated in 2 bytes<br>
		 * <br>
		 * See (3) below.<br>
		 * <br>
		 * Name : Unique identifier data<br>
		 * EPC : 0xBF<br>
		 * Data Type : unsigned short<br>
		 * Data Size(Byte) : 2<br>
		 * <br>
		 * AccessRule<br>
		 * Announce : undefined<br>
		 * Set : mandatory<br>
		 * Get : mandatory<br>
		 */
		public Setter reqSetUniqueIdentifierData(byte[] edt) {
			addProperty(EPC_UNIQUE_IDENTIFIER_DATA, edt, (edt.length == 2));
			return this;
		}
	}
	
	public class Getter extends ProfileObject.Getter {
		
		@Override
		public Getter reqGet(byte epc) {
			return (Getter)super.reqGet(epc);
		}
		@Override
		public Getter reqGetFaultStatus() {
			return (Getter)super.reqGetFaultStatus();
		}
		@Override
		public Getter reqGetManufacturerCode() {
			return (Getter)super.reqGetManufacturerCode();
		}
		@Override
		public Getter reqGetPlaceOfBusinessCode() {
			return (Getter)super.reqGetPlaceOfBusinessCode();
		}
		@Override
		public Getter reqGetProductCode() {
			return (Getter)super.reqGetProductCode();
		}
		@Override
		public Getter reqGetSerialNumber() {
			return (Getter)super.reqGetSerialNumber();
		}
		@Override
		public Getter reqGetDateOfManufacture() {
			return (Getter)super.reqGetDateOfManufacture();
		}
		@Override
		public Getter reqGetStatusChangeAnnouncementPropertyMap() {
			return (Getter)super.reqGetStatusChangeAnnouncementPropertyMap();
		}
		@Override
		public Getter reqGetSetPropertyMap() {
			return (Getter)super.reqGetSetPropertyMap();
		}
		@Override
		public Getter reqGetGetPropertyMap() {
			return (Getter)super.reqGetGetPropertyMap();
		}
		
		/**
		 * Indicates node operating status.<br>
		 * <br>
		 * Booting = 0x30, not booting = 0x31<br>
		 * <br>
		 * Name : Operating status<br>
		 * EPC : 0x80<br>
		 * Data Type : unsigned char<br>
		 * Data Size(Byte) : 1<br>
		 * <br>
		 * AccessRule<br>
		 * Announce : undefined<br>
		 * Set : optional<br>
		 * Get : mandatory<br>
		 * <br>
		 * Announcement at status change<br>
		 */
		public Getter reqGetOperatingStatus() {
			addProperty(EPC_OPERATING_STATUS);
			return this;
		}
		/**
		 * Indicates ECHONET Lite version<br>
		 * used by communication middleware and message types supported by communication middleware.<br>
		 * <br>
		 * 1st byte: Indicates major version number (digits to left of decimal point) in binary notation.<br>
		 * 2nd byte: Indicates minor version number (digits to right of decimal point) in binary notation.<br>
		 * 3rd and 4th bytes: Indicate message types with a bitmap.<br>
		 * <br>
		 * Name : Version information<br>
		 * EPC : 0x82<br>
		 * Data Type : unsigned char×4<br>
		 * Data Size(Byte) : 4<br>
		 * <br>
		 * AccessRule<br>
		 * Announce : undefined<br>
		 * Set : undefined<br>
		 * Get : mandatory<br>
		 */
		public Getter reqGetVersionInformation() {
			addProperty(EPC_VERSION_INFORMATION);
			return this;
		}
		/**
		 * Number to identify the node implementing the device object in the domain.<br>
		 * <br>
		 * 1st byte: lower communication ID field<br>
		 * 0x01 to 0xFD：<br>
		 * Set arbitrarily for the protocol when the communication protocol used in the lower communication layer has a unique number. (not used in the ECHONET Lite Specification)<br>
		 * 0xFE:<br>
		 * Set 2 to 17 bytes in the manufacturer-specified format.<br>
		 * 0xFF:<br>
		 * Set 2 to 9 bytes when the protocol generated by random numbers is used in the lower communication layer.<br>
		 * 0x00:<br>
		 * Identification number is not set.<br>
		 * Over 2nd byte: unique number field<br>
		 * <br>
		 * Name : Identification number<br>
		 * EPC : 0x83<br>
		 * Data Type : unsigned char×9 or unsigned char × 17<br>
		 * Data Size(Byte) : 9 or 17<br>
		 * <br>
		 * AccessRule<br>
		 * Announce : undefined<br>
		 * Set : undefined<br>
		 * Get : mandatory<br>
		 */
		public Getter reqGetIdentificationNumber() {
			addProperty(EPC_IDENTIFICATION_NUMBER);
			return this;
		}
		/**
		 * Fault content<br>
		 * <br>
		 * 0x0000-0x03E8 (0-1000)<br>
		 * <br>
		 * Name : Fault content<br>
		 * EPC : 0x89<br>
		 * Data Type : unsigned short<br>
		 * Data Size(Byte) : 2<br>
		 * <br>
		 * AccessRule<br>
		 * Announce : undefined<br>
		 * Set : undefined<br>
		 * Get : optional<br>
		 */
		public Getter reqGetFaultContent() {
			addProperty(EPC_FAULT_CONTENT);
			return this;
		}
		/**
		 * Stipulated in 2 bytes<br>
		 * <br>
		 * See (3) below.<br>
		 * <br>
		 * Name : Unique identifier data<br>
		 * EPC : 0xBF<br>
		 * Data Type : unsigned short<br>
		 * Data Size(Byte) : 2<br>
		 * <br>
		 * AccessRule<br>
		 * Announce : undefined<br>
		 * Set : mandatory<br>
		 * Get : mandatory<br>
		 */
		public Getter reqGetUniqueIdentifierData() {
			addProperty(EPC_UNIQUE_IDENTIFIER_DATA);
			return this;
		}
		/**
		 * Total number of instances held by self-node<br>
		 * <br>
		 * 1st to 3rd bytes: Total number of instances<br>
		 * <br>
		 * Name : Number of self-node instances<br>
		 * EPC : 0xD3<br>
		 * Data Type : unsigned char×3<br>
		 * Data Size(Byte) : 3<br>
		 * <br>
		 * AccessRule<br>
		 * Announce : undefined<br>
		 * Set : undefined<br>
		 * Get : mandatory<br>
		 */
		public Getter reqGetNumberOfSelfNodeInstances() {
			addProperty(EPC_NUMBER_OF_SELF_NODE_INSTANCES);
			return this;
		}
		/**
		 * Total number of classes held by self-node<br>
		 * <br>
		 * 1st and 2nd bytes: Total number of classes<br>
		 * <br>
		 * Name : Number of self-node classes<br>
		 * EPC : 0xD4<br>
		 * Data Type : unsigned char×2<br>
		 * Data Size(Byte) : 2<br>
		 * <br>
		 * AccessRule<br>
		 * Announce : undefined<br>
		 * Set : undefined<br>
		 * Get : mandatory<br>
		 */
		public Getter reqGetNumberOfSelfNodeClasses() {
			addProperty(EPC_NUMBER_OF_SELF_NODE_CLASSES);
			return this;
		}
		/**
		 * Self-node instance list<br>
		 * <br>
		 * 1st byte: Total number of instances<br>
		 * 2nd to 253rd bytes: ECHONET object codes (EOJ3 bytes) enumerated<br>
		 * <br>
		 * Name : Self-node instance list S<br>
		 * EPC : 0xD6<br>
		 * Data Type : unsigned char×(MAX) 253<br>
		 * Data Size(Byte) : Max.253<br>
		 * <br>
		 * AccessRule<br>
		 * Announce : undefined<br>
		 * Set : undefined<br>
		 * Get : mandatory<br>
		 */
		public Getter reqGetSelfNodeInstanceListS() {
			addProperty(EPC_SELF_NODE_INSTANCE_LIST_S);
			return this;
		}
		/**
		 * Self-node class list<br>
		 * <br>
		 * 1st byte: Total number of classes<br>
		 * 2nd to 17th bytes: Class codes (EOJ high-order 2 bytes) enumerated<br>
		 * <br>
		 * Name : Self-node class list<br>
		 * EPC : 0xD7<br>
		 * Data Type : unsigned char×(MAX) 17<br>
		 * Data Size(Byte) : Max.17<br>
		 * <br>
		 * AccessRule<br>
		 * Announce : undefined<br>
		 * Set : undefined<br>
		 * Get : mandatory<br>
		 */
		public Getter reqGetSelfNodeClassList() {
			addProperty(EPC_SELF_NODE_CLASS_LIST);
			return this;
		}
	}
	
	public interface Informer extends ProfileObject.Informer {
		public Informer reqInformFaultStatus();
		public Informer reqInformManufacturerCode();
		public Informer reqInformPlaceOfBusinessCode();
		public Informer reqInformProductCode();
		public Informer reqInformSerialNumber();
		public Informer reqInformDateOfManufacture();
		public Informer reqInformStatusChangeAnnouncementPropertyMap();
		public Informer reqInformSetPropertyMap();
		public Informer reqInformGetPropertyMap();
		
		/**
		 * Indicates node operating status.<br>
		 * <br>
		 * Booting = 0x30, not booting = 0x31<br>
		 * <br>
		 * Name : Operating status<br>
		 * EPC : 0x80<br>
		 * Data Type : unsigned char<br>
		 * Data Size(Byte) : 1<br>
		 * <br>
		 * AccessRule<br>
		 * Announce : undefined<br>
		 * Set : optional<br>
		 * Get : mandatory<br>
		 * <br>
		 * Announcement at status change<br>
		 */
		public Informer reqInformOperatingStatus();
		/**
		 * Indicates ECHONET Lite version<br>
		 * used by communication middleware and message types supported by communication middleware.<br>
		 * <br>
		 * 1st byte: Indicates major version number (digits to left of decimal point) in binary notation.<br>
		 * 2nd byte: Indicates minor version number (digits to right of decimal point) in binary notation.<br>
		 * 3rd and 4th bytes: Indicate message types with a bitmap.<br>
		 * <br>
		 * Name : Version information<br>
		 * EPC : 0x82<br>
		 * Data Type : unsigned char×4<br>
		 * Data Size(Byte) : 4<br>
		 * <br>
		 * AccessRule<br>
		 * Announce : undefined<br>
		 * Set : undefined<br>
		 * Get : mandatory<br>
		 */
		public Informer reqInformVersionInformation();
		/**
		 * Number to identify the node implementing the device object in the domain.<br>
		 * <br>
		 * 1st byte: lower communication ID field<br>
		 * 0x01 to 0xFD：<br>
		 * Set arbitrarily for the protocol when the communication protocol used in the lower communication layer has a unique number. (not used in the ECHONET Lite Specification)<br>
		 * 0xFE:<br>
		 * Set 2 to 17 bytes in the manufacturer-specified format.<br>
		 * 0xFF:<br>
		 * Set 2 to 9 bytes when the protocol generated by random numbers is used in the lower communication layer.<br>
		 * 0x00:<br>
		 * Identification number is not set.<br>
		 * Over 2nd byte: unique number field<br>
		 * <br>
		 * Name : Identification number<br>
		 * EPC : 0x83<br>
		 * Data Type : unsigned char×9 or unsigned char × 17<br>
		 * Data Size(Byte) : 9 or 17<br>
		 * <br>
		 * AccessRule<br>
		 * Announce : undefined<br>
		 * Set : undefined<br>
		 * Get : mandatory<br>
		 */
		public Informer reqInformIdentificationNumber();
		/**
		 * Fault content<br>
		 * <br>
		 * 0x0000-0x03E8 (0-1000)<br>
		 * <br>
		 * Name : Fault content<br>
		 * EPC : 0x89<br>
		 * Data Type : unsigned short<br>
		 * Data Size(Byte) : 2<br>
		 * <br>
		 * AccessRule<br>
		 * Announce : undefined<br>
		 * Set : undefined<br>
		 * Get : optional<br>
		 */
		public Informer reqInformFaultContent();
		/**
		 * Stipulated in 2 bytes<br>
		 * <br>
		 * See (3) below.<br>
		 * <br>
		 * Name : Unique identifier data<br>
		 * EPC : 0xBF<br>
		 * Data Type : unsigned short<br>
		 * Data Size(Byte) : 2<br>
		 * <br>
		 * AccessRule<br>
		 * Announce : undefined<br>
		 * Set : mandatory<br>
		 * Get : mandatory<br>
		 */
		public Informer reqInformUniqueIdentifierData();
		/**
		 * Total number of instances held by self-node<br>
		 * <br>
		 * 1st to 3rd bytes: Total number of instances<br>
		 * <br>
		 * Name : Number of self-node instances<br>
		 * EPC : 0xD3<br>
		 * Data Type : unsigned char×3<br>
		 * Data Size(Byte) : 3<br>
		 * <br>
		 * AccessRule<br>
		 * Announce : undefined<br>
		 * Set : undefined<br>
		 * Get : mandatory<br>
		 */
		public Informer reqInformNumberOfSelfNodeInstances();
		/**
		 * Total number of classes held by self-node<br>
		 * <br>
		 * 1st and 2nd bytes: Total number of classes<br>
		 * <br>
		 * Name : Number of self-node classes<br>
		 * EPC : 0xD4<br>
		 * Data Type : unsigned char×2<br>
		 * Data Size(Byte) : 2<br>
		 * <br>
		 * AccessRule<br>
		 * Announce : undefined<br>
		 * Set : undefined<br>
		 * Get : mandatory<br>
		 */
		public Informer reqInformNumberOfSelfNodeClasses();
		/**
		 * Instance list when self-node instance configuration is changed<br>
		 * <br>
		 * 1st byte: Number of notification instances<br>
		 * 2nd to 253rd bytes: ECHONET object codes (EOJ3 bytes) enumerated<br>
		 * <br>
		 * Name : Instance list notification<br>
		 * EPC : 0xD5<br>
		 * Data Type : unsigned char×(MAX) 253<br>
		 * Data Size(Byte) : Max.253<br>
		 * <br>
		 * AccessRule<br>
		 * Announce : mandatory<br>
		 * Set : undefined<br>
		 * Get : undefined<br>
		 * <br>
		 * Announcement at status change<br>
		 */
		public Informer reqInformInstanceListNotification();
		/**
		 * Self-node instance list<br>
		 * <br>
		 * 1st byte: Total number of instances<br>
		 * 2nd to 253rd bytes: ECHONET object codes (EOJ3 bytes) enumerated<br>
		 * <br>
		 * Name : Self-node instance list S<br>
		 * EPC : 0xD6<br>
		 * Data Type : unsigned char×(MAX) 253<br>
		 * Data Size(Byte) : Max.253<br>
		 * <br>
		 * AccessRule<br>
		 * Announce : undefined<br>
		 * Set : undefined<br>
		 * Get : mandatory<br>
		 */
		public Informer reqInformSelfNodeInstanceListS();
		/**
		 * Self-node class list<br>
		 * <br>
		 * 1st byte: Total number of classes<br>
		 * 2nd to 17th bytes: Class codes (EOJ high-order 2 bytes) enumerated<br>
		 * <br>
		 * Name : Self-node class list<br>
		 * EPC : 0xD7<br>
		 * Data Type : unsigned char×(MAX) 17<br>
		 * Data Size(Byte) : Max.17<br>
		 * <br>
		 * AccessRule<br>
		 * Announce : undefined<br>
		 * Set : undefined<br>
		 * Get : mandatory<br>
		 */
		public Informer reqInformSelfNodeClassList();
	}
	
	public class InformerImpl extends ProfileObject.InformerImpl implements Informer {
		@Override
		public Informer reqInformFaultStatus() {
			return (Informer)super.reqInformFaultStatus();
		}
		@Override
		public Informer reqInformManufacturerCode() {
			return (Informer)super.reqInformManufacturerCode();
		}
		@Override
		public Informer reqInformPlaceOfBusinessCode() {
			return (Informer)super.reqInformPlaceOfBusinessCode();
		}
		@Override
		public Informer reqInformProductCode() {
			return (Informer)super.reqInformProductCode();
		}
		@Override
		public Informer reqInformSerialNumber() {
			return (Informer)super.reqInformSerialNumber();
		}
		@Override
		public Informer reqInformDateOfManufacture() {
			return (Informer)super.reqInformDateOfManufacture();
		}
		@Override
		public Informer reqInformStatusChangeAnnouncementPropertyMap() {
			return (Informer)super.reqInformStatusChangeAnnouncementPropertyMap();
		}
		@Override
		public Informer reqInformSetPropertyMap() {
			return (Informer)super.reqInformSetPropertyMap();
		}
		@Override
		public Informer reqInformGetPropertyMap() {
			return (Informer)super.reqInformGetPropertyMap();
		}

		@Override
		public Informer reqInformOperatingStatus() {
			byte epc = EPC_OPERATING_STATUS;
			byte[] edt = _getOperatingStatus(epc);
			addProperty(epc, edt, (edt != null && edt.length == 1));
			return this;
		}

		@Override
		public Informer reqInformVersionInformation() {
			byte epc = EPC_VERSION_INFORMATION;
			byte[] edt = _getVersionInformation(epc);
			addProperty(epc, edt, (edt != null && edt.length == 4));
			return this;
		}

		@Override
		public Informer reqInformIdentificationNumber() {
			byte epc = EPC_IDENTIFICATION_NUMBER;
			byte[] edt = _getIdentificationNumber(epc);
			addProperty(epc, edt, (edt != null && (edt.length == 9 || edt.length == 11)));
			return this;
		}

		@Override
		public Informer reqInformFaultContent() {
			byte epc = EPC_FAULT_CONTENT;
			byte[] edt = _getFaultContent(epc);
			addProperty(epc, edt, (edt != null && edt.length == 2));
			return this;
		}

		@Override
		public Informer reqInformUniqueIdentifierData() {
			byte epc = EPC_UNIQUE_IDENTIFIER_DATA;
			byte[] edt = _getUniqueIdentifierData(epc);
			addProperty(epc, edt, (edt != null && edt.length == 2));
			return this;
		}

		@Override
		public Informer reqInformNumberOfSelfNodeInstances() {
			byte epc = EPC_NUMBER_OF_SELF_NODE_INSTANCES;
			byte[] edt = _getNumberOfSelfNodeInstances(epc);
			addProperty(epc, edt, (edt != null && edt.length == 3));
			return this;
		}

		@Override
		public Informer reqInformNumberOfSelfNodeClasses() {
			byte epc = EPC_NUMBER_OF_SELF_NODE_CLASSES;
			byte[] edt = _getNumberOfSelfNodeClasses(epc);
			addProperty(epc, edt, (edt != null && edt.length == 2));
			return this;
		}

		@Override
		public Informer reqInformInstanceListNotification() {
			byte epc = EPC_INSTANCE_LIST_NOTIFICATION;
			byte[] edt = _getInstanceListNotification(epc);
			addProperty(epc, edt, (edt != null && edt.length <= 253));
			return this;
		}

		@Override
		public Informer reqInformSelfNodeInstanceListS() {
			byte epc = EPC_SELF_NODE_INSTANCE_LIST_S;
			byte[] edt = _getSelfNodeInstanceListS(epc);
			addProperty(epc, edt, (edt != null && edt.length <= 253));
			return this;
		}

		@Override
		public Informer reqInformSelfNodeClassList() {
			byte epc = EPC_SELF_NODE_CLASS_LIST;
			byte[] edt = _getSelfNodeClassList(epc);
			addProperty(epc, edt, (edt != null && edt.length <= 17));
			return this;
		}
		
	}
	
	public class InformerProxy extends ProfileObject.InformerProxy implements Informer {
		@Override
		public Informer reqInformFaultStatus() {
			return (Informer)super.reqInformFaultStatus();
		}
		@Override
		public Informer reqInformManufacturerCode() {
			return (Informer)super.reqInformManufacturerCode();
		}
		@Override
		public Informer reqInformPlaceOfBusinessCode() {
			return (Informer)super.reqInformPlaceOfBusinessCode();
		}
		@Override
		public Informer reqInformProductCode() {
			return (Informer)super.reqInformProductCode();
		}
		@Override
		public Informer reqInformSerialNumber() {
			return (Informer)super.reqInformSerialNumber();
		}
		@Override
		public Informer reqInformDateOfManufacture() {
			return (Informer)super.reqInformDateOfManufacture();
		}
		@Override
		public Informer reqInformStatusChangeAnnouncementPropertyMap() {
			return (Informer)super.reqInformStatusChangeAnnouncementPropertyMap();
		}
		@Override
		public Informer reqInformSetPropertyMap() {
			return (Informer)super.reqInformSetPropertyMap();
		}
		@Override
		public Informer reqInformGetPropertyMap() {
			return (Informer)super.reqInformGetPropertyMap();
		}
		
		@Override
		public Informer reqInformOperatingStatus() {
			addProperty(EPC_OPERATING_STATUS);
			return this;
		}
		@Override
		public Informer reqInformVersionInformation() {
			addProperty(EPC_VERSION_INFORMATION);
			return this;
		}
		@Override
		public Informer reqInformIdentificationNumber() {
			addProperty(EPC_IDENTIFICATION_NUMBER);
			return this;
		}
		@Override
		public Informer reqInformFaultContent() {
			addProperty(EPC_FAULT_CONTENT);
			return this;
		}
		@Override
		public Informer reqInformUniqueIdentifierData() {
			addProperty(EPC_UNIQUE_IDENTIFIER_DATA);
			return this;
		}
		@Override
		public Informer reqInformNumberOfSelfNodeInstances() {
			addProperty(EPC_NUMBER_OF_SELF_NODE_INSTANCES);
			return this;
		}
		@Override
		public Informer reqInformNumberOfSelfNodeClasses() {
			addProperty(EPC_NUMBER_OF_SELF_NODE_CLASSES);
			return this;
		}
		@Override
		public Informer reqInformInstanceListNotification() {
			addProperty(EPC_INSTANCE_LIST_NOTIFICATION);
			return this;
		}
		@Override
		public Informer reqInformSelfNodeInstanceListS() {
			addProperty(EPC_SELF_NODE_INSTANCE_LIST_S);
			return this;
		}
		@Override
		public Informer reqInformSelfNodeClassList() {
			addProperty(EPC_SELF_NODE_CLASS_LIST);
			return this;
		}
	}
	

	public class InformerC extends EchoObject.InformerC {
		/**
		 * Instance list when self-node instance configuration is changed<br>
		 * <br>
		 * 1st byte: Number of notification instances<br>
		 * 2nd to 253rd bytes: ECHONET object codes (EOJ3 bytes) enumerated<br>
		 * <br>
		 * Name : Instance list notification<br>
		 * EPC : 0xD5<br>
		 * Data Type : unsigned char×(MAX) 253<br>
		 * Data Size(Byte) : Max.253<br>
		 * <br>
		 * AccessRule<br>
		 * Announce : mandatory<br>
		 * Set : undefined<br>
		 * Get : undefined<br>
		 * <br>
		 * Announcement at status change<br>
		 */
		public InformerC informInstanceListNotification() {
			byte epc = EPC_INSTANCE_LIST_NOTIFICATION;
			byte[] edt = _getInstanceListNotification(epc);
			addProperty(epc, edt, (edt != null && edt.length <= 253));
			return this;
		}
		
	}
}
